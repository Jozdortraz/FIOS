---
layout: default
title: LeetCode
permalink: /leetcode/p7
---
# P7. [Reverse Integer](https://leetcode.com/problems/reverse-integer/description/)

## 题目
![P7]({{ site.baseurl }}/assets/leetcode/p7.png)


## 题意分析
这道题的核心是逆序一个32位有符号整数。根据测试用例以及题目描述，我们一共有三种情况需要处理：
- 正数
- 负数
- 逆序完会溢出的数

## 分类讨论
- 正数

    显然，对于一般的正数，我们可以依次取出数字中的每一位，进行加总，成为最终需要的逆序数：
    
    >以 123 为例：
    >
    >依次取出1，2，3，并进行拼合： 1 * 1 + 2 * 10 + 3 * 100 = 321

- 负数

    对于负数，因其逆序之后符号并不会发生变化，我们可以将其符号提出来，使用逆序正数的方法，直接逆序符号之后的数字即可

- 逆序完会溢出的数

    在题目的最后，题目描述中提出，我们只需输出逆序后符合范围 \[−2<sup>31</sup>,  2<sup>31</sup> − 1\] 的数，即\[-2147483648, 2147483647]范围内的数。
    
    我们需要检测最终的结果是否在这个范围内，如果不在则返回0
    

## 本题考点
通过分类讨论，我们可以看出本题的考点：

- 从一个整数中分离每一位上的数字
- 逆序拼合
- 溢出情况的处理

## 实现过程模拟
首先，我们可以通过x对10取余，也就是`x % 10`来获取整数x的个位数；

接下来通过`x / 10`来让x缩小10倍，此时再操作`x % 10`，则可获得原整数的十位数，以此类推，就可以将原整数x的每一位分离出来。

我们将分离出来的数字存入一个数组中，从第一位开始，依次乘以1，10，100...，并加总，以此来实现逆序的效果。

最后判断加总的结果是否越界，如果越界，则返回0

## 实现

```java
class Solution {
  public int reverse(int x) {
  // 定义数组存储每一位，因为是32位整数，所以最多不会超过32位
    int[] digits = new int[32]; 

    // 分离每一位，并存入数组
    // 如果是负数，则存入的每一位都是负值
    // 最后逆序加总得到的值也是负数
    // 所以正数负数均可以使用同一套逻辑分离数位
    int digitsPointer = 0;
    while (x != 0) {
      digits[digitsPointer++] = x % 10;
      x /= 10;
    }

    // 逆序相加，这里使用long来存储，因为会有int溢出的情况
    long sum = 0, factor = 1;
    for(int i = digitsPointer - 1; i >= 0; i --) {
      sum += digits[i] * factor;
      factor *= 10;
    }

    // 判断是否越界
    // Java 中，Integer.MAX_VALUE对应的是2147483647
    // Integer.MIN_VALUE对应的是-2147483648
    if (sum >= 0) {
      return sum > Integer.MAX_VALUE ? 0 : (int)sum;
    } else {
      return sum < Integer.MIN_VALUE ? 0 : (int)sum;
    }
    
  }
}
```

## 优化
总体上，整个程序顺利AC，也成功击败了100%的用户。

我们现在来观察第一个while循环和第二个for循环，可以发现，其实这两个循环可以合并。

也就是说，完全没有必要使用数组存储整个数字分离的过程

## 优化实现
```java
class Solution {
  public int reverse(int x) {
    long sum = 0;
    while (x != 0) {
      // 在这里，我们失去了数组的帮助
      // 需要通过每次让上次的结果乘以10加上本轮数字的个位数
      // 以达到逆序的效果
      // 比如 123, 则sum值的变化为
      // 0 -> 0 * 10 + 3 = 3 -> 3 * 10 + 2 = 32 -> 32 * 10 + 1 = 321
      
      sum = sum * 10 + (x % 10);
      x /= 10;
    }

    // 判断是否越界
    if (sum >= 0) {
      return sum > Integer.MAX_VALUE ? 0 : (int)sum;
    } else {
      return sum < Integer.MIN_VALUE ? 0 : (int)sum;
    }
  }
}
```

## 拓展
优化后的方案已经很完美了，我们跳出这道题，考虑以下情况：

**如果题目从32位整数，变成了64位整数，long不够用的情况下该如何实现呢？**

有一种方法是，将对应的上界下届换成新的上下界就可以了。

但我们仍然需要将`long`类型换成一个更大范围的类型，以保存我们逆序后的结果。

如果有一种情况，在这种条件下，最大的类型，比如`double`，都不够用了，我们如何能够判断逆序后的结果是否越界呢？

有没有一种方法，可以不用定义更大的类型，来实现越界的判断呢？

我们要从`int`越界的原理开始说起。

Java 中，int默认的范围是 \[−2<sup>31</sup>,  2<sup>31</sup> − 1\]

我们以上界为例，2<sup>31</sup> − 1对应成电脑中的二进制表示为：

> 0111 1111 1111 1111 1111 1111 1111 1111

因为第一位为符号位，所以这是32位有符号整数所能表示的最大数值，也就是2147483647。

当我们将这个数+1， 变成2147483648时，本来应该是：

> 1000 0000 0000 0000 0000 0000 0000 0000

但这个值因为有符号的关系，在32位有符号整数中，首位为符号位，当首位为1时，表示的是二进制的负数，而二进制负数是通过正值的补码进行表示。

我们将`1000 0000 0000 0000 0000 0000 0000 0000`还原为正值：

首先将`1000 0000 0000 0000 0000 0000 0000 0000`减去1, 得到

> 0111 1111 1111 1111 1111 1111 1111 1111

再将其取反码，得到

> 1000 0000 0000 0000 0000 0000 0000 0000 = 2147483648

所以`1000 0000 0000 0000 0000 0000 0000 0000`作为负数时的值为`-2147483648`

也就是我们造成了 `2147483647 + 1 = -2147483648`，导致了int的溢出

同理，如果我们将2147483647 + 2:

> 0111 1111 1111 1111 1111 1111 1111 1111
>
> \+ 
>
> 0000 0000 0000 0000 0000 0000 0000 0010
>
> ======================================
> 
> 1000 0000 0000 0000 0000 0000 0000 0001

`1000 0000 0000 0000 0000 0000 0000 0001` 作为负数的值为`-2147483647`

综上，我们得到了：

`2147483647 + 1 = -2147483648`

`2147483647 + 2 = -2147483647`

据此我们可以得出一个简单的结论：

若`a + b = c`, 记不发生溢出时的结果 `a + b = c1`, 溢出时的结果`a + b = c2`,

则有 `c1 != c2`

对于本问题，我们逆序相加的算式为：

`sum = sum * 10 + (x % 10);`

记 `a = sum * 10`, `b = x % 10`,

则`a + b` 在不发生溢出时为`c1`, 溢出时为`c2`,

有 `c1 != c2` => `c1 - b != c2 - b` => `(c1 - b) / 10 != (c2 - b) / 10`

又有 `b / 10 == 0`, 则有 `c1 / 10 != c2 / 10`

即**上一轮的结果sum != 溢出时的本轮结果sum / 10**

结论：

>**若本轮结果/10与上一轮结果相同，则没有溢出；**
>
>**若本轮结果/10与上一轮结果不同，则溢出；**

## 实现

```java
class Solution {
  public int reverse(int x) {
    int sum = 0;
    
    while (x != 0) {
      int newSum = sum * 10 + x % 10;

      // 本轮结果/10 不等于 上一轮结果，则溢出
      if (newSum / 10 != sum) {
        return 0;
      }

      sum = newSum;

      x /= 10;
    }

    return sum;
  }
}
```





